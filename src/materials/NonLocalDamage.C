/****************************************************************/
/*               DO NOT MODIFY THIS HEADER                      */
/*                       BlackBear                              */
/*                                                              */
/*           (c) 2017 Battelle Energy Alliance, LLC             */
/*                   ALL RIGHTS RESERVED                        */
/*                                                              */
/*          Prepared by Battelle Energy Alliance, LLC           */
/*            Under Contract No. DE-AC07-05ID14517              */
/*            With the U. S. Department of Energy               */
/*                                                              */
/*            See COPYRIGHT for full restrictions               */
/****************************************************************/

#include "NonLocalDamage.h"

#include "RankTwoTensor.h"
#include "RankFourTensor.h"
#include "ElasticityTensorTools.h"
#include "MooseUtils.h"
#include <cmath>
#include "RankTwoScalarTools.h"
#include "libmesh/utility.h"

registerMooseObject("BlackBearApp", NonLocalDamage);
registerMooseObject("BlackBearApp", ADNonLocalDamage);

template <bool is_ad>
InputParameters
NonLocalDamageTempl<is_ad>::validParams()
{
  InputParameters params = ScalarDamageBaseTempl<is_ad>::validParams();
  params.addClassDescription(
      "Nonlocal damage model. Given an RadialAverage UO this creates a new damage index that can "
      "be used as for ComputeDamageStress without havign to change existing local damage models.");
  params.addRequiredParam<UserObjectName>("average_UO", "Radial Average user object");
  params.addRequiredParam<MaterialName>("local_damage_model",
                                        "Name of the local damage model used to compute "
                                        "the nonlocal damage index");
  return params;
}

template <bool is_ad>
NonLocalDamageTempl<is_ad>::NonLocalDamageTempl(const InputParameters & parameters)
  : ScalarDamageBaseTempl<is_ad>(parameters),
    GuaranteeConsumer(this),
    _average(this->template getUserObject<RadialAverage>("average_UO").getAverage()),
    _local_damage_model_name(this->template getParam<MaterialName>("local_damage_model"))
{
}
template <bool is_ad>
void
NonLocalDamageTempl<is_ad>::initialSetup()
{
  _local_damage_model = dynamic_cast<ScalarDamageBaseTempl<is_ad> *>(
      &this->getMaterialByName(_local_damage_model_name));

  if (!_local_damage_model)
    this->template paramError("damage_model",
                              "Damage Model " + _local_damage_model_name +
                                  " is not compatible with NonLocalDamage model");
  _average_damage = _average.find(-1);
}

template <bool is_ad>
void
NonLocalDamageTempl<is_ad>::initQpStatefulProperties()
{
  ScalarDamageBaseTempl<is_ad>::initQpStatefulProperties();
}

template <bool is_ad>
void
NonLocalDamageTempl<is_ad>::updateQpDamageIndex()
{
  // First update underlying local damage model
  _local_damage_model->getQpDamageIndex(_qp);
  // Now update the nonlocal damage model
  // Only update iterator when we change to another element
  if (_qp == 0)
    _average_damage = _average.find(_current_elem->id());
  // _prev_elem_id = _current_elem->id()
  // Make sure that we find the new element if not return 0
  if (_average_damage != _average.end())
    // return max of the old damage or new average damage
    _damage_index[_qp] = std::max(_average_damage->second[_qp], _damage_index_old[_qp]);
  else
    // during startup the map is not made yet
    // if AMR is used then the new element will not be found but it should
    // already have an old nonlocal damage value that needs to perserved
    _damage_index[_qp] = std::max(0.0, _damage_index_old[_qp]);
}

template class NonLocalDamageTempl<false>;
template class NonLocalDamageTempl<true>;
